<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>


    <script src="../../js/mylib.js"></script>
</head>
<body>
    <h1>로또 번호 만들기, 중복체크로 로직을 이용하기(매우중요함)</h1>
    <input type="button" value="번호생성하기" onclick="f_lotto()">
    <div id="id_disp" style="border: 1px solid pink"></div>
<script>
    var v_disp = document.querySelector("#id_disp");

    // 개발자는 중복을 싫어한다.
    // 처음 결과를 얻기위해 만든 코드를 다시 깔끔하고 매끄럽게 정리하는 것을
    // Refactoring이라고 한다.
    // 실제로는 정리하는 중에 코드가 더 깔끔해지고 , 성능이 좋아지는 부분이 있어서
    // refactoring라고 부른다.

    // function f_repeat(p_arr,p_val){
    //     for(var i=0; i<p_arr.length; i++) {
    //         if(p_arr[i] == p_val){
    //             return true; // 중복값이 있음
    //         }
    //     }
    //     return false; // 중복 값이 없음
    //     // refactoring을 시도했더니, 의외로 소스가 더 간단해진다.
    // }


///============================================================================================
/*
    function f_lotto() {
        var v_lottoNums = []; // 번호를 담을 배열
        for(;"몇번만에 6개가 될지 알수 없다.";){ // 무한루프 발생
            var v_ranNum = f_ranNum(1,45);
        

        // 중복체크가 발생한 번호가 배열에 이미 있는지(true) 없는지(false)
        // 개별 비교가 아닌 전체 루프 뒤에 넣을지 않넣을지를 결정해야한다.
        var v_isExist = false; // 없다고 가정함. //// 매우중요!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        for(var i=0; i<v_lottoNums.length; i++) {
            if(v_lottoNums[i] == v_ranNum){
               v_isExist = true; // 없다고 가정했는데 이미 값이 있음
               break; // 더는 for문이 돌지 않음
            }
        }
        // 이제 결정할 수 있음 넣을 지 안 넣을지
        if(!v_isExist){
            v_lottoNums.push(v_ranNum);
        }

        // 무한루프는 항상 빠져나갈 조건을 먼저 생각하고 정의한다.
        if(v_lottoNums.length ==6){
            v_disp.innerHTML += "<h1>" + v_lottoNums + "</h1>"; // 출력
            break;
            }
        }
    }
*/  

//=============================================================================================
/*
    // 중복 값 체크 코드
    // 배열 객체의 indexOf 메소드는 찾으면 해당 index, 몾 찾으면 -1을 리턴한다.
    function f_repeat(p_arr,p_val){
        for(var i=0; i<p_arr.length; i++) {
            if(p_arr[i] == p_val){
                return true; // 
            }
        }
        return false;  // 
    }

    // 로또 번호 구하기 중복값 없이 refactoring 한 방법
    function f_lotto() {
        var v_lottoNums = []; 
        for(;"몇번만에 6개가 될지 알수 없다.";){ 
            var v_ranNum = f_ranNum(1,45);

            // 위의 중복코드를 사용해서 코드를 간략화 함
            if(!f_repeat(v_lottoNums, v_ranNum)){
                v_lottoNums.push(v_ranNum);
            }

            if(v_lottoNums.length ==6){
                v_disp.innerHTML += "<h1>" + v_lottoNums + "</h1>"; 
                break;
            }
        }
    }
*/
    //=============================================================================================
    // 중복 값 체크 코드
    // 배열 객체의 indexOf 메소드는 찾으면 해당 index, 몾 찾으면 -1을 리턴한다.
    function f_repeat(p_arr,p_val){
        for(var i=0; i<p_arr.length; i++) {
            if(p_arr[i] == p_val){
                return true; // return i  몇번째 index 인지 확인
            }
        }
        return false;  // return -1 아닐때 -1을 확인
    }

    // 로또 번호 구하기 중복값 없이 refactoring 한 방법
    function f_lotto() {
        var v_lottoNums = []; 
        for(;"몇번만에 6개가 될지 알수 없다.";){ 
            var v_ranNum = f_ranNum(1,45);

            // indexof를 이용한 방법
            if(v_lottoNums.indexOf(v_ranNum)== -1){
                v_lottoNums.push(v_ranNum);
            }

            if(v_lottoNums.length ==6){
                v_disp.innerHTML += "<h1>" + v_lottoNums + "</h1>"; 
                break;
            }
        }
    }
</script>    
</body>
</html>